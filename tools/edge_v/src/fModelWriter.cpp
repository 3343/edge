/**
 * @file This file is part of EDGE.
 *
 * @author David Lenz (dlenz AT ucsd.edu)
 *
 * @section LICENSE
 * Copyright (c) 2018, Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @section DESCRIPTION
 * This file is an example of how to use the FaultRegion class to generate
 * initial data on a fault for dynamic rupture simulations. This example models
 * the TPV5 benchmark ( http://scecdata.usc.edu/cvws/tpv5docs.html ). To model
 * other benchmarks, you may need to extend the FaultRegion family of classes
 * to fit your use case.
 **/

#include <unistd.h>
#include "FaultRegion.h"

std::string parseOFileName( int i_argc, char** i_argv ){
  int opt;
  std::string l_oFileName, l_helpMessage;
  bool l_oFileProvided = false;

  l_helpMessage =
    "fModelWriter is a script to create input files specifying initial    \n"
    "data on a fault for use with EDGE-V. The files generated by          \n"
    "fModelWriter may be passed to EDGE-V under the fault_input parameter \n"
    "in the annotation config file.\n"
    "\n"
    "Usage:                                        \n"
    "    fModelWriter -o <outputFile>              \n"
    "    fModelWriter -h                           \n"
    "                                              \n"
    "Options:                                      \n"
    "    -o   Name of file to be written to.       \n"
    "    -h   Print this help message.             \n";

  while ((opt = getopt ( i_argc, i_argv, "o:h")) != -1){
    switch (opt){
      case 'o':
        l_oFileName = optarg;
        l_oFileProvided = true;
        std::cout << "Output file: " << optarg << std::endl;
        break;
      case 'h':
        std::cout << l_helpMessage << std::endl;
        exit( -1 );
        break;
      case '?':
        std::cout << l_helpMessage << std::endl;
        exit( -1 );
        break;
    }
  }

  if( !l_oFileProvided ){
    std::cout << "Please specify a file path for output" << std::endl
                                                         << std::endl;
    std::cout << l_helpMessage << std::endl;
    exit( -1 );
  }

  return l_oFileName;
}

int main( int argc, char** argv ){
  std::string l_oFileName = parseOFileName( argc, argv );

  const int l_gridSpacing =     50;
  const double l_xMin     = -20000;
  const double l_xMax     =  20000;
  const double l_yMin     =      0;
  const double l_yMax     =  20000;
  const int l_Nx = trunc( (l_xMax - l_xMin) / l_gridSpacing );
  const int l_Ny = trunc( (l_yMax - l_yMin) / l_gridSpacing );

  const double l_faultAngle = 0;
  const double l_cos = cos( l_faultAngle );
  const double l_sin = sin( l_faultAngle );


  // Construct all of the fault regions
  FR_static l_background( l_xMin, l_xMax, l_yMin, l_yMax );
  l_background.insert( "S_FRIC", 10000 );
  l_background.insert( "S_STRESS_STK", 70 );
  l_background.insert( "S_STRESS_DIP", 0 );
  l_background.insert( "N_STRESS", 120 );
  l_background.insert( "STRESS_DROP", 0 );

  FR_static l_ruptureArea( -15000, 15000, 0, 15000 );
  l_ruptureArea.insert( "S_FRIC", 0.677 );
  l_ruptureArea.insert( "S_STRESS_STK", 70 );
  l_ruptureArea.insert( "S_STRESS_DIP", 0 );
  l_ruptureArea.insert( "N_STRESS", 120 );
  l_ruptureArea.insert( "STRESS_DROP", 7 );

  FR_tpv5Nucleate   l_nuclPatch(  -1500,  1500, 6000, 9000 );
  FR_tpv5LowStress  l_lowStress(   6000,  9000, 6000, 9000 );
  FR_tpv5HighStress l_highStress( -9000, -6000, 6000, 9000 );

  // TODO (for robustness) Add method to check that quantities match between
  // regions
  // consistencyCheck( l_background, l_ruptureArea, .. )


  // Create and write file header
  std::stringstream l_lineBuf;
  std::ofstream l_output;

  l_output.open( l_oFileName.c_str() );

  l_lineBuf << l_Nx << " " << l_Ny << " "
            << l_xMin << " " << l_xMax << " " << l_yMin << " " << l_yMax << " ";
  for( const auto& l_qName : l_background.m_qtyNames ){
    l_lineBuf << l_qName << " ";
  }

  l_lineBuf << std::endl;  if( l_oFileName != "" )
  l_output << l_lineBuf.str();


  // Loop over all grid points and test containment in each fault region
  // Grid points are ordered beginning with min x and y coords, increasing
  // first in pos. x direction and next in pos. y direction.
  // Note: the perimeter of computational domain may not contain grid points
  int j = 0, k = 0;
  xyz_point_t l_pt;
  while( (l_yMin + k * l_gridSpacing) * l_cos <= l_yMax ){
    j = 0;
    while( (l_xMin + j * l_gridSpacing) * l_cos <= l_xMax ){
      l_pt.x = (l_xMin + j * l_gridSpacing) * l_cos;
      l_pt.y = l_yMin + k * l_gridSpacing;
      l_pt.z = (l_xMin + j * l_gridSpacing) * l_sin;

      if( l_nuclPatch.contains( l_pt ) )
        l_output  << j << " " << k << " "
                  << l_pt.x << " " << l_pt.y << " " << l_pt.z << " "
                  << l_nuclPatch.getAllQuantities( l_pt ) << " " << std::endl;
      else if( l_lowStress.contains( l_pt ) )
        l_output  << j << " " << k << " "
                  << l_pt.x << " " << l_pt.y << " " << l_pt.z << " "
                  << l_lowStress.getAllQuantities( l_pt ) << " " << std::endl;
      else if( l_highStress.contains( l_pt ) )
        l_output  << j << " " << k << " "
                  << l_pt.x << " " << l_pt.y << " " << l_pt.z << " "
                  << l_highStress.getAllQuantities( l_pt ) << " " << std::endl;
      else if( l_ruptureArea.contains( l_pt ) )
        l_output  << j << " " << k << " "
                  << l_pt.x << " " << l_pt.y << " " << l_pt.z << " "
                  << l_ruptureArea.getAllQuantities( l_pt ) << " " << std::endl;
      else if( l_background.contains( l_pt ) )
        l_output  << j << " " << k << " "
                  << l_pt.x << " " << l_pt.y << " " << l_pt.z << " "
                  << l_background.getAllQuantities( l_pt ) << " " << std::endl;
      else{
        l_output << "Error: Attempted to write out of scope point" << std::endl;
        l_output << l_pt.x << " " << l_pt.y << " " << l_pt.z << std::endl;
        std::cerr << "Error: Attempted to write out of scope point" << std::endl;
        std::cerr << l_pt.x << " " << l_pt.y << " " << l_pt.z << std::endl;
      }
      l_output.flush();
      j++;
    }
    k++;
  }

  l_output.close();

  return 0;
}
